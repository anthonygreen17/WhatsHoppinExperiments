

Experiment #1:    Good
	- Get API token
	- Make API requests to BreweryDB
	- figure out what paths we will use in the application

	- figure out how much data we need to store
		- possibly, figure out how to put JSON on disk with Elixir



Experiment #2:    Good
	- JS Websockets
		- figure out how to structure channels
			- "updates/brewery/{brewery.name}"
			- "updates/beer/{beer.name}"





Potential Ideas:

	Experiment:
		- render data into the form that we want
		- do we want to take in JSON from API calls and put them into a database?

	Experiment:
		- figure out how to use search bar
		- figure out how to index what ur looking at(maybe by first letter?)


Other notes:

	- use a forum style where messages are saved forever, with reference to user
	- 


get a certain category:
http://api.brewerydb.com/v2/category/5/?key=b8858d9cead79d462f430e9726080163

get all categories:


Findings:

	- we cant do a GET to all beers (/beers). To get around that, we should have the following structure:
	- Category:
		- Style:
			- Beer:

	every beer has a style, every style has a category, and a GET to /categories is legal. Boom.




	Database stuff:

	Beer Table:
		- name (string)
		- abv (int/string)
		- ibu (int/string)
		- styleId (reference to style)

	Brewery Table:
		- name (string)
		- website (string)
		- established_date (int)
		- isMassOwned? (bool)
		- brandClassification  (eg. "craft")

	Style:
		- styleId (int)
		- categoryId (reference to category)
		- name
		- shortname??
		- ibuMin
		- ibuMax
		- abvMin
		- abvMax

	Category:
		- name
		- categoryId (int)







Request a resource according to a certain key:

http://api.brewerydb.com/v2/breweries/?key=API_KEY&p=3



On the hardware side, we are past an initial working implementation and now trying to conserve power as much as possible. The Beacon sleeps after it transmits data with the transceiver until the next byte comes in from the GPS module. This sleep mode is "IDLE", which consumes the most power out of all sleep modes, so we are looking into other methods to allow use to use a deeper sleep in order to consume less power in the time between Beacon transmissions (specifically, the watchdog timer interrupt). Additionally, we have been thinking about the fact that our project currently only supports Beacon/Receiver communication on a single, non configurable frequency range. This means that we won't be able to use more than one Beacon/Receiver pair in the same area since the Receiver has no way to tell which Beacon is which and also since there is a high chance that Beacon transmissions would collide would each other. We'd like to discuss our options in regards to this issue.